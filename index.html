<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - pointerlock controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;

			}
            #crosshair {
                position: absolute;
                top: 50%;;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 50px;
                color: rgba(255,255,255,0.5);
            }

		</style>
	</head>
	<body>
        <script type="text/javascript" src="https://threejs.org/build/three.min.js"></script>
		<script src="utils/PointerLockControls.js"></script>
		<script src="utils/GLTFLoader.js"></script>
		<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</div>

		</div>
        <div id="crosshair">
            &#8853;
        </div>

		<script>

			var camera, scene, renderer, controls;

			var objects = [];

			var raycaster;
            var cameraDirection = new THREE.Vector3(0,0,0);
            //var rc;
            var tempTarget = new THREE.Vector3(0,0,0);
            var arrow
            var arrows = [];

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();

            var model, clips, mixer, animations, action;
            var model_arrow;

            var clock = new THREE.Clock();

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x222222 );
				scene.fog = new THREE.Fog( 0x222222, 0, 600 );

				var light = new THREE.AmbientLight( 0xffffff, 2.4 );
				scene.add( light );

				controls = new THREE.PointerLockControls( camera );

				var blocker = document.getElementById( 'blocker' );
				var instructions = document.getElementById( 'instructions' );

				instructions.addEventListener( 'click', function () {

					controls.lock();

				}, false );

				controls.addEventListener( 'lock', function () {

					instructions.style.display = 'none';
					blocker.style.display = 'none';

				} );

				controls.addEventListener( 'unlock', function () {

					blocker.style.display = 'block';
					instructions.style.display = '';

				} );

				scene.add( controls.getObject() );

                var grid = new THREE.GridHelper(2000, 200);
                scene.add(grid);

				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if ( canJump === true ) velocity.y += 350;
							canJump = false;
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

                };
                var onMouseDown = function ( event ) {
                    arrow = model_arrow.clone();
                    arrow.position.copy(camera.getWorldPosition());
                    arrow.quaternion.copy(camera.getWorldQuaternion());
                    scene.add(arrow);
                    arrows.push(arrow);


                };




				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );
				document.addEventListener( 'mousedown', onMouseDown, false );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

				// floor

				var floorGeo = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
				floorGeo.rotateX( - Math.PI / 2 );

				// vertex displacement

				var floorMaterial = new THREE.MeshStandardMaterial( { color: 0x006600 } );

				var floor = new THREE.Mesh( floorGeo, floorMaterial );
				scene.add( floor );

                var centerGeo = new THREE.BoxGeometry(50, 50, 50);
                var centerMat = new THREE.MeshBasicMaterial({color: 0xff0000});
                var center = new THREE.Mesh(centerGeo, centerMat);
                center.position.y += 25;
                scene.add( center );


                //THREE.DracoLoader.setDecoderPath('./');
                var loader = new THREE.GLTFLoader();
                loader.load(
                    'gltf/monkey.glb',
                    function(gltf) {
                        model = gltf.scene;
                        scene.add(model);

                        clips = gltf.animations;

                        model.scale.set(10,10,10);
                        model.translateY(10);
                        model.translateZ(50);

                        //var clip = THREE.AnimationClip.findByName(clips, "SuzanneAction");
                        mixer = new THREE.AnimationMixer(model.children[0]);
                        action = mixer.clipAction(clips[0]);
                        action.play();

                    },
                    function(xhr) {
                        console.log('loading');
                    },
                    function(error) {
                        console.log('errrrror');
                    }
                );

                loader.load(
                    'gltf/fort.glb',
                    function(gltf) {
                        var model2 = gltf.scene;
                        scene.add(model2);

                        model2.scale.set(8,8,8);
                        model2.translateY(-50);
                        model2.translateX(-140);
                        model2.translateZ(-170);

                        //var clip = THREE.AnimationClip.findByName(clips, "SuzanneAction");
                    },
                    function(xhr) {
                        console.log('loading');
                    },
                    function(error) {
                        console.log('errrrror');
                    }
                );

                loader.load(
                    'gltf/arrow.glb',
                    function(gltf) {
                        model_arrow = gltf.scene;
                        model_arrow.scale.set(3,3,3);
                        model_arrow.position.set(11, 145, -25);
                   },
                    function(xhr) {
                        console.log('loading');
                    },
                    function(error) {
                        console.log('errrrror');
                    }
                );

                loader.load(
                    'gltf/tree.glb',
                    function(gltf) {
                        var tree = gltf.scene;
                        tree.scale.set(15,15,15);
                        tree.position.set(450, 10, 450);
                        scene.add(tree);
                   },
                    function(xhr) {
                        console.log('loading');
                    },
                    function(error) {
                        console.log('errrrror');
                    }
                );

				controls.getObject().translateZ( 100 );
                //camera.position.z = 100;

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				if ( controls.isLocked === true ) {

                    console.log(controls.getObject().position);

					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;

					var intersections = raycaster.intersectObjects( objects );

					var onObject = intersections.length > 0;

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;

                    if(mixer != null) {
                        mixer.update(delta);
                    }
                    model.lookAt(controls.getObject().position);
                    model.translateZ(delta*10);

					velocity.x -= velocity.x * 5.0 * delta;
					velocity.z -= velocity.z * 5.0 * delta;

					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveLeft ) - Number( moveRight );
					direction.normalize(); // this ensures consistent movements in all directions

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

                    //rc.set(camera.getWorldPosition(tempTarget), controls.getObject().position);
					if ( onObject === true ) {

						velocity.y = Math.max( 0, velocity.y );
						canJump = true;

					}

					controls.getObject().translateX( velocity.x * delta );
					controls.getObject().translateY( velocity.y * delta );
					controls.getObject().translateZ( velocity.z * delta );

					if ( controls.getObject().position.y < 140 ) {
						velocity.y = 0;
						controls.getObject().position.y = 140;
						canJump = true;

					}

                    //outer wall collision
					if ( controls.getObject().position.z < -160 ) {
						controls.getObject().position.z = -160;

					}
                    if ( controls.getObject().position.z > 96 ) {
						controls.getObject().position.z = 96;

					}
					if ( controls.getObject().position.x < -104 ) {
						controls.getObject().position.x = -104;

					}
                    if ( controls.getObject().position.x > 120 ) {
						controls.getObject().position.x = 120;

					}

                    arrows.forEach(a => {
                        a.translateZ(-300*delta);
                    });



					prevTime = time;

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
